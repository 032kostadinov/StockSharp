<?xml version="1.0" encoding="utf-8"?>
<topic id="a0a4c8df-2bba-4e1e-8ba9-e1fa98728f92" revisionNumber="0">
  <developerWalkthroughDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <summary>
      <para>Данный топик предназначен для трейдеров, которые разрабатывают графические торговые программы с
	  помощью <token>stocksharp</token>, но недостаточно знакомы с азами программирования графического интерфейса под <token>dotnet</token>.</para>
    </summary>

    <introduction>
      <para>В <token>dotnet</token> существует специальная технология для построения графического интерфейса – <token>wpf</token> (до этого была
	  технология <token>winforms</token>, которая значительно уступает по графическим возможностям). В этой технологии для создания графических элементов 
	  используется специальный декларативынй язык <externalLink>
		<linkText>XAML</linkText>
		<linkAlternateText>eXtensible Application Markup Language</linkAlternateText>
		<linkUri>https://msdn.microsoft.com/ru-ru/library/hh700354.aspx</linkUri>
		<linkTarget>_blank</linkTarget>
		</externalLink>.</para>
	  <para>Основное ограничение визуального API под Windows состоит в том, что нельзя обращаться из другого потока к элементам окна. Это связанно с ограничениями архитектуры Windows (подробнее описано здесь
	  <token>messagepump</token>). Реализации шлюза <codeEntityReference>T:StockSharp.BusinessEntities.IConnector</codeEntityReference> в целях повышения
	  производительности работают в многопоточном режиме. Поэтому, подписываясь на событие, например, 
	  <codeEntityReference qualifyHint="true">E:StockSharp.BusinessEntities.IConnector.NewSecurities</codeEntityReference>,
	  нельзя напрямую выводить полученные данные в окно пользователя. Для этого нужно провести операцию синхронизации при помощи специального объекта
	  <externalLink>
		<linkText>Dispatcher</linkText>
		<linkAlternateText>Dispatcher</linkAlternateText>
		<linkUri>https://msdn.microsoft.com/ru-ru/library/system.windows.threading.dispatcher(v=vs.110).aspx</linkUri>
		<linkTarget>_blank</linkTarget>
		</externalLink>, который управляет очередью рабочих элементов потока. </para>
	  <para> Вот простой пример, как это делается:</para>
	  <code language="C#">
// обязательно нужно вызвать метод BeginInvoke,
// и уже в его обработчике можно обратиться к элементу окна 'Security' (это выпадающий список)
_trader.NewSecurities += securities => this.Dispatcher.BeginInvoke((Action)(() => this.Security.ItemsSource = _trader.Securities));</code>
	  <para>
		<token>stocksharp</token> уже содержит специальные методы, которые скрывают использование Dispatcher и упрощают написание кода:
	  </para>
	  <code language="C#">// обязательно нужно вызвать метод GuiSync, прежде чем обратиться к элементу окна 'Security' (это выпадающий список)
_trader.NewSecurities += securities => this.GuiSync(() => this.Security.ItemsSource = _trader.Securities);</code>

<section address="optionalAddress">
  <title>Графические компоненты S#</title>
  <content>
    <para>В состав <token>stocksharp</token> входит большое количество собственных графических компонент, а так же бесплатная библиотека графических компонент для Wpf
    <externalLink>
	<linkText>Xceed.Wpf.Toolkit</linkText>
<linkAlternateText>Optional alternate text</linkAlternateText>
<linkUri>http://wpftoolkit.codeplex.com/</linkUri>
<linkTarget>_blank</linkTarget>
</externalLink>. Собственные графические компоненты размещены в пространствах имен <codeEntityReference qualifyHint="true">N:StockSharp.Xaml</codeEntityReference>, <codeEntityReference qualifyHint="true">N:StockSharp.Xaml.Charting</codeEntityReference>
и <codeEntityReference qualifyHint="true">N:StockSharp.Xaml.Diagram</codeEntityReference>. Условно компоненты можно разделить на следующие группы: </para>


<list class="bullet">
  <listItem><para>Для ввода поиска биржевой информации</para></listItem>
  <listItem><para>Для отображения биржевой информации</para></listItem>
  <listItem><para>Для построения графиков</para></listItem>
</list>

<para>
	 Для доступа к графическим контролам <token>stocksharp</token> в коде XAML необходимо определить псевдонимы для соотвествующих пространств имен. Как это сделать показано в следующем
	 примере:
</para>
	  <code language="C#">// обязательно нужно вызвать метод GuiSync, прежде чем обратиться к элементу окна 'Security' (это выпадающий список)
_trader.NewSecurities += securities => this.GuiSync(() => this.Security.ItemsSource = _trader.Securities);</code>

<para>
	 Ниже приведена таблица с описанием некоторых полезных графических компонент, входящих в состав <token>stocksharp</token>:
</para>

<table>
  <tableHeader>
    <row>
      <entry><para>Компонент</para></entry>
      <entry><para>Описание</para></entry>
    </row>
  </tableHeader>
  <row>
    <entry><para>MonitorWindow</para></entry>
    <entry><para>Компонент для отображения информации из логов</para></entry>
  </row>
</table>

 
  </content>
</section>



 
	  
	  <!--<para>
		Для того, чтобы не осложнять процесс разработки торговых программ деталями и ограничениями, <token>stocksharp</token> содержит специальный шлюз
		<codeEntityReference>T:StockSharp.Xaml.GuiTrader`1</codeEntityReference>. Данный класс синхронизует события в один поток, и нет необходимости делать
		это в коде. Вышеприведенный код с использованием <codeEntityReference>T:StockSharp.Xaml.GuiTrader`1</codeEntityReference>:
	  </para>
	  <code language="C#">// теперь можно обратиться к элементу окна 'Security' (это выпадающий список) без конструкции GuiSync
_trader.NewSecurities += securities => this.Security.ItemsSource = _trader.Securities;</code>
	  <para>
		Для менеджера свечек <codeEntityReference>T:StockSharp.Algo.Candles.CandleManager</codeEntityReference> также существует синхронизованный
		вариант. Для того, чтобы получать синхронизованно события свечек 
		<codeEntityReference qualifyHint="false">E:StockSharp.Algo.Candles.CandleManager.Processing</codeEntityReference>,
		  необходимо создать <codeEntityReference>T:StockSharp.Algo.Candles.CandleManager</codeEntityReference> и передать в него несинхронизованный шлюз
		  <codeEntityReference>T:StockSharp.BusinessEntities.IConnector</codeEntityReference> (можно передавать и <codeEntityReference>T:StockSharp.Xaml.GuiTrader`1</codeEntityReference>,
		  но в этом случае будет происходить двойная синхронизация).
	  </para> -->
    </introduction>

    <!-- <procedure>
      <title>Пример SampleSync</title>

      <steps class="ordered">
        <step>
          <content>
            <para>В самом начале необходимо создать подключение к торговой системе и синхронизовать его:</para>
			<code language="C#"><![CDATA[
// создаем шлюз к Quik-у и синхронизуем его
_trader = new QuikTrader(this.Path.Text).GuiSyncTrader();

// или напрямую через конструктор GuiTrader
// (пред. нужно закомментировать, это - раскомментировать)
// new GuiTrader<QuikTrader>(new QuikTrader(this.Path.Text));

// производим соединение
_trader.Connect();]]></code>
          </content>
        </step>
		<step>
		  <content>
			<para>Затем, подписаться на событие, в обработчике которого уже не нужно вызывать синхронизацию:</para>
			<code language="C#">// теперь можно обратиться к элементу окна 'Security' (это выпадающий список) без конструкции GuiSync
_trader.NewSecurities += securities => this.Security.ItemsSource = _trader.Securities;</code>
		  </content>
		</step>
		<step>
		  <content>
			<para>Работа со свечками, где также не требуется синхронизация:</para>
			<code language="C#"><![CDATA[
// создаем синхронизованный менеджер свечек по несинхронизованному шлюзу
_candleManager = new CandleManager(_trader.Trader);

private void ShowChart_Click(object sender, RoutedEventArgs e)
{
	var security = (Security)Security.SelectedValue;
	var series = new CandleSeries(typeof(TimeFrameCandle), security, TimeSpan.FromMinutes(5));
	_chartWindows.SafeAdd(series, key =>
	{
		var wnd = new ChartWindow
		{
			Title = "{0} {1}".Put(security.Code, series.Arg)
		};

		wnd.MakeHideable();

		series.ProcessCandle += candle => wnd.Chart.Candles.Add(candle);

		return wnd;
	}).Show();

	_candleManager.Start(series);
}
			]]>
			</code>
			<alert class="note">
			  Исходники примера лежат в папке SampleSync.
			</alert>
		  </content>
		</step>
      </steps>
    </procedure>

	<section>
      <title>Недостаток синхронизованного шлюза GuiTrader</title>

      <content>
		<para>
		  Основным минусом такого подхода является то, что графические операции (например, прорисовка графиков или таблиц, в зависимости от того,
		  какой будет сделан интерфейс) и торговые операции будут выполняться в одном потоке. А это приведет к тому, что данные операции будут
		  делить между собой процессорное время. И, если на компьютере установлен процессор с несколькими ядрами, то будет задействовано только
		  одно из них, а другие в это время будут простаивать. Визуально это будет проявляться в том, что окно с данными будет замирать на период
		  обработки события. И наоборот, событие будет дожидаться, пока полностью не прорисуется окно.
		</para>
		<para>
		  Как резюме, такое решение стоит использовать только в начале разработки роботов, когда еще нет достаточного опыта по написанию
		  автономным торговых программ с графическим интерфейсом.
		</para>
      </content>
    </section> -->

    
    
    
  </developerWalkthroughDocument>
</topic>