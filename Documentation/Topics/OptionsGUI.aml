<?xml version="1.0" encoding="utf-8"?>
<topic id="667d9230-82d2-4052-9e23-6cdd983d3461" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>
      В состав <token>stocksharp</token> входит несколько графических компонент для работы с опционами. Во-первых, это доска опционов
      <codeEntityReference>T:StockSharp.Xaml.OptionDesk</codeEntityReference>, во-вторых - график, показывающий позицию и греки опционов относительно базового актива 
      <codeEntityReference>T:StockSharp.Xaml.Charting.OptionPositionChart</codeEntityReference>.
      
      </para>
    </introduction>
    
    <section>
		<sections>
			<section address="SubSection1">
			<title>Графический компонент OptionDesk</title>
				<content>
					<mediaLink><image placement="left" xlink:href="option_desk" /></mediaLink>
                  	<para><codeEntityReference>T:StockSharp.Xaml.OptionDesk</codeEntityReference> - таблица для отображения доски опционов. Показывает "греки", вмененную волатильность,
                  	 теоретическую цену, лучший оффер и бид для Put и Call опционов.</para>
                	<procedure>
                		<title>Пример OptionCalculator</title>
                		<para>Исходные коды примера OptionCalculator можно найти в папке <legacyItalic>Samples/Options/OptionCalculator</legacyItalic>.</para>
						<steps class="ordered">
							<step>
							<content>
								<para>В коде XAML добавляем элемент <codeEntityReference>T:StockSharp.Xaml.OptionDesk</codeEntityReference>
								и присваиваем ему имя <legacyBold>Desk</legacyBold>.</para>
            					 <code title="XAML" language="XAML">
	  				<![CDATA[
<Window x:Class="OptionCalculator.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:loc="clr-namespace:StockSharp.Localization;assembly=StockSharp.Localization"
        xmlns:xaml="http://schemas.stocksharp.com/xaml"
        xmlns:xctk="http://schemas.xceed.com/wpf/xaml/toolkit"
        Title="{x:Static loc:LocalizedStrings.XamlStr396}" Height="400" Width="1030">
    <Grid Margin="5,5,5,5">
    
	    .........................................................
	    
	    <xaml:OptionDesk x:Name="Desk" Grid.Row="6" Grid.ColumnSpan="3" Grid.Column="0" />
    
	</Grid>
</Window>
	  				]]>
                  				</code>
							</content>
							</step>
							<step>
							<content>
								<para>В коде C# создаем подключение. В зависимости от выбранного типа коннектора инициализируем экземпляр 
								<codeEntityReference>T:StockSharp.Quik.QuikTrader</codeEntityReference> или <codeEntityReference>T:StockSharp.Plaza.PlazaTrader</codeEntityReference>.
								Если Quik используется в режиме DDE, то настраиваем дополнительные колонки опционов.</para>
            					<code title="C#" language="C#">
                  <![CDATA[
if (_connector == null)
{
	if (IsQuik.IsChecked == true)
	{
		var isDde = IsDde.IsChecked == true;

		if (isDde && Path.Text.IsEmpty())
		{
			MessageBox.Show(this, LocalizedStrings.Str2969);
			return;
		}

		// создаем подключение
		var trader = new QuikTrader(Path.Text)
		{
			IsDde = isDde
		};

		if (isDde)
		{
			// изменяем метаданные так, чтобы начали обрабатывать дополнительные колонки опционов
			var columns = trader.SecuritiesTable.Columns;
			columns.Add(DdeSecurityColumns.Strike);
			columns.Add(DdeSecurityColumns.ImpliedVolatility);
			columns.Add(DdeSecurityColumns.UnderlyingSecurity);
			columns.Add(DdeSecurityColumns.TheorPrice);
			columns.Add(DdeSecurityColumns.OptionType);
			columns.Add(DdeSecurityColumns.ExpiryDate);
			trader.DdeTables = new[] { trader.SecuritiesTable, trader.TradesTable };
		}

		_connector = trader;
	}
	else
	{
		var trader = new PlazaTrader
		{
			Address = Address.Text.To<EndPoint>(),
			IsCGate = IsCGate.IsChecked == true
		};

		trader.Tables.Add(trader.TableRegistry.Volatility);
			
		if (IsAutorization.IsChecked == true)
		{
			trader.Login = Login.Text;
			trader.Password = Password.Password;
		}

		_connector = trader;
	}
}
]]>
                  				</code>
							</content>
							</step>
							<step>
							<content>
								<para>Задаем провайдера сообщений для рыночных данных и инструментов.</para>
            					<code title="C#" language="C#">
                  <![CDATA[
Desk.MarketDataProvider = _connector;
Desk.SecurityProvider = _connector;
Desk.CurrentTime = null;
]]>
                  			</code>
							</content>
							</step>
							<step>
							<content>
								<para>При получении инструментов:</para>
								<list class="ordered">
  									<listItem>Заполняем коллекцию фьючерсов для выпадающего списка;</listItem>
  									<listItem>Инициалицируем выбранный инструмент первым элементом этой коллекции;</listItem>
  									<listItem>Заполняем массив цепочкой опционов, где подлежащим активом выступает выбранный инструмент;</listItem>
  									<listItem>Присваиваем свойству <codeEntityReference qualifyHint="true">P:StockSharp.Xaml.OptionDesk.Options</codeEntityReference> этот массив;</listItem>
  									<listItem>Обновляем значения доски опционов при помощи метода 
  									<codeEntityReference qualifyHint="true">M:StockSharp.Xaml.OptionDesk.RefreshOptions()</codeEntityReference>.</listItem>
								</list>

            					<code title="C#" language="C#">
                  <![CDATA[
_connector.NewSecurities += securities =>
	this.GuiAsync(() =>
	{
		// добавляем в выпадающий список (подлежащие инструменты) только фьючерсы
		_assets.AddRange(securities.Where(s => s.Type == SecurityTypes.Future));

		if (SelectedAsset == null && _assets.Count > 0)
			SelectedAsset = _assets.First();

		if (SelectedAsset != null)
		{
			var newStrikes = securities
				.Where(s => s.Type == SecurityTypes.Option && s.UnderlyingSecurityId.CompareIgnoreCase(SelectedAsset.Id))
				.ToArray();

			if (newStrikes.Length > 0)
			{
				_options.AddRange(newStrikes);
				Desk.Options = _options;
				Desk.RefreshOptions();
			}
		}
	});
]]>
                  				</code>
							</content>
							</step>
							<step>
							<content>
								<para>При изменении параметров опционов:</para>
								<list class="ordered">
  									<listItem>Заполняем массив опционами, которые не были добавлены ранее в коллекцию опционов контрола;</listItem>
  									<listItem>Если добавлены новые опционы, то обновляем значение свойства 
  									<codeEntityReference qualifyHint="true">P:StockSharp.Xaml.OptionDesk.Options</codeEntityReference>;</listItem>
  									<listItem>
  									 Если были добавлены новые опционы или изменились параметры ранее добавленных опционов, то обновляем доску опционов 
  									<codeEntityReference qualifyHint="true">M:StockSharp.Xaml.OptionDesk.RefreshOptions()</codeEntityReference>.</listItem>
								</list>
            					<code title="C#" language="C#">
                  <![CDATA[
_connector.SecuritiesChanged += securities =>
{
	this.GuiAsync(() =>
	{
		if (SelectedAsset == null)
			return;
			
		var newStrikes = securities
				.Where(s => s.Type == SecurityTypes.Option && s.UnderlyingSecurityId.CompareIgnoreCase(SelectedAsset.Id))
				.Where(s => !_options.Contains(s))
				.ToArray();

		if (newStrikes.Length > 0)
		{
			_options.AddRange(newStrikes);
			Desk.Options = _options;
			Desk.RefreshOptions();
		}

		if (Desk.Options.Intersect(securities).Any())
			Desk.RefreshOptions();
	});
};

]]>
                  				</code>
							</content>
							</step>
						</steps>
 					</procedure>
              </content>
          </section>
          <section address="SubSection2">
              <title>Графический компонент OptionPositionChart</title>
              <content>
              	<mediaLink><image placement="left" xlink:href="option_volsmile" /></mediaLink>
              	<para>
                	<codeEntityReference>T:StockSharp.Xaml.Charting.OptionPositionChart</codeEntityReference> - график, показывающий позицию и греки опционов относительно базового актива.
                </para>
               
                <procedure>
                		<title>Пример SampleOptionQuoting</title>
                		<para>Исходные коды примера SampleOptionQuoting можно найти в папке <legacyItalic>Samples/Options/SampleOptionQuoting</legacyItalic>.</para>
						<steps class="ordered">
							<step>
							<content>
								<para>В коде XAML добавляем элемент <codeEntityReference>T:StockSharp.Xaml.Charting.OptionPositionChart</codeEntityReference>
								и присваиваем ему имя <legacyBold>PosChart</legacyBold>.</para>
            					 <code title="XAML" language="XAML">
	  				<![CDATA[
<Window x:Class="OptionCalculator.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:loc="clr-namespace:StockSharp.Localization;assembly=StockSharp.Localization"
        xmlns:xaml="http://schemas.stocksharp.com/xaml"
        xmlns:xctk="http://schemas.xceed.com/wpf/xaml/toolkit"
        Title="{x:Static loc:LocalizedStrings.XamlStr396}" Height="400" Width="1030">
    <Grid Margin="5,5,5,5">
    
	    .........................................................
	    
	    <xaml:OptionPositionChart x:Name="PosChart" Grid.Row="7" Grid.Column="0" Grid.ColumnSpan="6" />

	</Grid>
</Window>
				]]>
                  				</code>
							</content>
							</step>
							<step>
							<content>
								<para>В коде C# создаем подключение	<codeEntityReference>T:StockSharp.Quik.QuikTrader</codeEntityReference>,
								если Quik используется в режиме DDE, то настраиваем дополнительные колонки опционов.</para>
            					<code title="C#" language="C#">
                  <![CDATA[
var isDde = IsDde.IsChecked == true;

if (isDde && Path.Text.IsEmpty())
{
	MessageBox.Show(this, LocalizedStrings.Str2969);
	return;
}

if (Connector != null && !(Connector is FakeConnector))
		return;

// создаем подключение
Connector = new QuikTrader(Path.Text)
{
	IsDde = isDde
};

if (isDde)
{
	// изменяем метаданные так, чтобы начали обрабатывать дополнительные колонки опционов
	var columns = ((QuikTrader)Connector).SecuritiesTable.Columns;
	columns.Add(DdeSecurityColumns.Strike);
	columns.Add(DdeSecurityColumns.ImpliedVolatility);
	columns.Add(DdeSecurityColumns.UnderlyingSecurity);
	columns.Add(DdeSecurityColumns.TheorPrice);
	columns.Add(DdeSecurityColumns.OptionType);
	columns.Add(DdeSecurityColumns.ExpiryDate);
}

]]>
                  				</code>
							</content>
							</step>
							<step>
							<content>
							<para>Задаем первоначальные установки контрола:</para>
							<list class="ordered">
  								<listItem>
  									Обнуляем коллекции позиций опционов
  									<codeEntityReference>P:StockSharp.Xaml.Charting.OptionPositionChart.Positions</codeEntityReference> и подлежащего инструмента
									<codeEntityReference>P:StockSharp.Xaml.Charting.OptionPositionChart.AssetPosition</codeEntityReference> контрола;
								</listItem>
  								<listItem>
  									Перерисовываем график с начальными значениями
									<codeEntityReference>M:StockSharp.Xaml.Charting.OptionPositionChart.Refresh(System.Decimal,System.Decimal,System.DateTimeOffset,System.DateTimeOffset)</codeEntityReference>;
								</listItem>
							  	<listItem>Задаем провайдера сообщений для рыночных данных и инструментов.</listItem>
							</list>
							
            				<code title="C#" language="C#">
                  <![CDATA[
PosChart.Positions.Clear();
PosChart.AssetPosition = null;
PosChart.Refresh(1, 1, default(DateTimeOffset), default(DateTimeOffset));

PosChart.MarketDataProvider = Connector;
PosChart.SecurityProvider = Connector;


]]>
                  			</code>
							</content>
							</step>
							<step>
							<content>
								<para>При получении инструментов добавляем базовые активы в список.</para>
            					<code title="C#" language="C#">
                  <![CDATA[
Connector.NewSecurities += securities =>
		_assets.AddRange(securities.Where(s => s.Type == SecurityTypes.Future));
]]>
                  				</code>
							</content>
							</step>
							<step>
							<content>
								<para>При изменении Level1 базового инструмента или опционов, а также при получении новой сделки возводим флаг _isDirty. 
								Это позволяет в событии таймера (код, которого опущен) вызывать метод RefreshChart (см. ниже) для перерисовки графика.
								Таким образом мы контролируем частоту перерисовки.</para>
            					<code title="C#" language="C#">
                  <![CDATA[
Connector.SecuritiesChanged += securities =>
{
	if ((PosChart.AssetPosition != null && securities.Contains(PosChart.AssetPosition.Security)) || PosChart.Positions.Cache.Select(p => p.Security).Intersect(securities).Any())
		_isDirty = true;
};

// подписываемся на событие новых сделок чтобы обновить текущую цену фьючерса
Connector.NewTrades += trades =>
{
	var assetPos = PosChart.AssetPosition;
	if (assetPos != null && trades.Any(t => t.Security == assetPos.Security))
		_isDirty = true;
			};
]]>
                  				</code>
							</content>
							</step>
							<step>
							<content>
								<para>В обработчике события появления новой позиции обновляем свойства  
								<codeEntityReference>P:StockSharp.Xaml.Charting.OptionPositionChart.Positions</codeEntityReference> и
								<codeEntityReference>P:StockSharp.Xaml.Charting.OptionPositionChart.AssetPosition</codeEntityReference> контрола. 
								В этом случае, а также при изменении позициии, вызываем перерисовку графика.</para>
            					<code title="C#" language="C#">
                  <![CDATA[
Connector.NewPositions += positions => this.GuiAsync(() =>
{
	var asset = SelectedAsset;

	if (asset == null)
		return;

	var assetPos = positions.FirstOrDefault(p => p.Security == asset);
	var newPos = positions.Where(p => p.Security.UnderlyingSecurityId == asset.Id).ToArray();

	if (assetPos == null && newPos.Length == 0)
		return;

	if (assetPos != null)
		PosChart.AssetPosition = assetPos;

	if (newPos.Length > 0)
		PosChart.Positions.AddRange(newPos);

	RefreshChart();
});

Connector.PositionsChanged += positions => this.GuiAsync(() =>
{
	if ((PosChart.AssetPosition != null && positions.Contains(PosChart.AssetPosition)) || positions.Intersect(PosChart.Positions.Cache).Any())
		RefreshChart();
});

]]>
                  				</code>
							</content>
							</step>
							<step>
							<content>
								<para>Метод вызывает перерисовку графика.</para>
            					<code title="C#" language="C#">
                  <![CDATA[
private void RefreshChart()
{
	var asset = SelectedAsset;
	var trade = asset.LastTrade;

	if (trade != null)
		PosChart.Refresh(trade.Price, asset.PriceStep ?? 1m, TimeHelper.Now, asset.ExpiryDate ?? DateTimeOffset.Now.Date + TimeSpan.FromDays(1));
}

]]>
                  				</code>
							</content>
							</step>
						</steps>
 					</procedure>
              </content>
          </section>
	</sections>
</section>

    <relatedTopics>
		<link xlink:href="063708c5-b6a8-45f6-9ff9-608f89796a88">Греки</link>
		<link xlink:href="6fe5b321-a23d-415d-b3e3-af9de9212a20">Котирование по волатильности</link>
    </relatedTopics>
    
  </developerConceptualDocument>
</topic>